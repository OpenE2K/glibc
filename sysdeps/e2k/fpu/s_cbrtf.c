/* Copyright (c) 2016-2018 ZAO "MCST". All rights reserved. */

#include "f2c.h"

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                        %
%  ПРОГРАММА  ВЫЧИСЛЯЕТ  КОРЕНЬ  КУБИЧЕСКИЙ  ИЗ  ЧИСЛА Х.%
%                                                        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

static const DB constcbrtf[] = {
    1.0000000000000000000,    /* CBRT (1+ 0/32) */
    1.0103100051555475677,    /* CBRT (1+ 1/32) */
    1.0204137754793370177,    /* CBRT (1+ 2/32) */
    1.0303213249521392048,    /* CBRT (1+ 3/32) */
    1.0400419115259520573,    /* CBRT (1+ 4/32) */
    1.0495841134521019305,    /* CBRT (1+ 5/32) */
    1.0589558960637232910,    /* CBRT (1+ 6/32) */
    1.0681646704244792062,    /* CBRT (1+ 7/32) */
    1.0772173450159418608,    /* CBRT (1+ 8/32) */
    1.0861203714421529754,    /* CBRT (1+ 9/32) */
    1.0948797849719723164,    /* CBRT (1+10/32) */
    1.1035012406105259432,    /* CBRT (1+11/32) */
    1.1119900452846577606,    /* CBRT (1+12/32) */
    1.1203511866392911772,    /* CBRT (1+13/32) */
    1.1285893588685003448,    /* CBRT (1+14/32) */
    1.1367089859440859734,    /* CBRT (1+15/32) */
    1.1447142425533318678,    /* CBRT (1+16/32) */
    1.1526090730146116424,    /* CBRT (1+17/32) */
    1.1603972084031947232,    /* CBRT (1+18/32) */
    1.1680821820888149211,    /* CBRT (1+19/32) */
    1.1756673438603787448,    /* CBRT (1+20/32) */
    1.1831558727908421353,    /* CBRT (1+21/32) */
    1.1905507889761496060,    /* CBRT (1+22/32) */
    1.1978549642656959927,    /* CBRT (1+23/32) */
    1.2050711320876149931,    /* CBRT (1+24/32) */
    1.2122018964599698346,    /* CBRT (1+25/32) */
    1.2192497402683283315,    /* CBRT (1+26/32) */
    1.2262170328810041755,    /* CBRT (1+27/32) */
    1.2331060371652350508,    /* CBRT (1+28/32) */
    1.2399189159605752048,    /* CBRT (1+29/32) */
    1.2466577380596615041,    /* CBRT (1+30/32) */
    1.2533244837411461579,    /* CBRT (1+31/32) */
    1.2599210498948731648     /* CBRT (1+32/32) */
};

static const DB constcbrtf_dop[] = {
    1.0000000000000000000e+00,  /* (1+ 0/32)^(-11/3)  */
    8.9330303111757313611e-01,  /* (1+ 1/32)^(-11/3)  */
    8.0068290836812096826e-01,  /* (1+ 2/32)^(-11/3)  */
    7.1994683124232525327e-01,  /* (1+ 3/32)^(-11/3)  */
    6.4929304520809323284e-01,  /* (1+ 4/32)^(-11/3)  */
    5.8723274646476543773e-01,  /* (1+ 5/32)^(-11/3)  */
    5.3252916724420600947e-01,  /* (1+ 6/32)^(-11/3)  */
    4.8414973083602250541e-01,  /* (1+ 7/32)^(-11/3)  */
    4.4122822451852980078e-01,  /* (1+ 8/32)^(-11/3)  */
    4.0303470626331350745e-01,  /* (1+ 9/32)^(-11/3)  */
    3.6895142244190013738e-01,  /* (1+10/32)^(-11/3)  */
    3.3845342764156875523e-01,  /* (1+11/32)^(-11/3)  */
    3.1109290523092400805e-01,  /* (1+12/32)^(-11/3)  */
    2.8648641752939648096e-01,  /* (1+13/32)^(-11/3)  */
    2.6430448798712855721e-01,  /* (1+14/32)^(-11/3)  */
    2.4426304949960990514e-01,  /* (1+15/32)^(-11/3)  */
    2.2611639359078161709e-01,  /* (1+16/32)^(-11/3)  */
    2.0965133251700613669e-01,  /* (1+17/32)^(-11/3)  */
    1.9468234611177414246e-01,  /* (1+18/32)^(-11/3)  */
    1.8104753164997777290e-01,  /* (1+19/32)^(-11/3)  */
    1.6860521131795496252e-01,  /* (1+20/32)^(-11/3)  */
    1.5723108039516604571e-01,  /* (1+21/32)^(-11/3)  */
    1.4681580176603037144e-01,  /* (1+22/32)^(-11/3)  */
    1.3726297023535185213e-01,  /* (1+23/32)^(-11/3)  */
    1.2848738434586816484e-01,  /* (1+24/32)^(-11/3)  */
    1.2041357477916205559e-01,  /* (1+25/32)^(-11/3)  */
    1.1297454756769257561e-01,  /* (1+26/32)^(-11/3)  */
    1.0611070772507577770e-01,  /* (1+27/32)^(-11/3)  */
    9.9768934878593644203e-02,  /* (1+28/32)^(-11/3)  */
    9.3901787346992951179e-02,  /* (1+29/32)^(-11/3)  */
    8.8466815071317256812e-02,  /* (1+30/32)^(-11/3)  */
    8.3425965052751429112e-02,  /* (1+31/32)^(-11/3)  */
    7.8745065618429580874e-02   /* (1+32/32)^(-11/3)  */
};

#define K1 (1.0/3)
#define K2 (5.0/81)
#define K3 (10.0/243)
#define KCBRT2 1.2599210498948731648
#define KCBRT4 1.5874010519681994748

float
__cbrtf (float x)
{
    _type_float_bits arg;
    _type_double_bits darg, x0, por;
    DB y, x0v2, dxv2;
    LL ind, exp, ost;

    arg.value = ffabs (x);
    if (__glibc_unlikely (arg.int0 >= 0x7f800000 || arg.int0 == 0))
        return x + x;                                       /* 0, NaN or Inf */
    darg.value = (DB) arg.value;
    exp = exponentabs (darg);
    ind = 341;
    exp *= 2731;
    ost = exp >> 11;
    exp = ((exp >> 13) - ind) << 52;
//    ind = darg.llong & 0xfffffffffffffLL;
//    darg.llong = ind | 0x3ff0000000000000LL;
//    ind = (ind + 0x400000000000LL) & 0x1f800000000000LL;
//    x0.llong = ind + 0x3ff0000000000000LL;
    ind = __builtin_e2k_pandd (darg.llong, 0xfffffffffffffLL);
    darg.llong = __builtin_e2k_pord (ind, 0x3ff0000000000000LL);
    ind = __builtin_e2k_paddd (ind, 0x400000000000LL);
    ind = __builtin_e2k_pandd (ind, 0x1f800000000000LL);
    x0.llong = __builtin_e2k_paddd (ind, 0x3ff0000000000000LL);
    darg.value -= x0.value;
    x0v2 = x0.value * x0.value;
    dxv2 = darg.value * darg.value;
    y = K1 * darg.value;
    y = y * x0v2 * (y - x0.value) + K2 * darg.value * dxv2 * ((K3 / K2) * darg.value - x0.value);
    x0.value = constcbrtf[ind >>= 47];
    por.value = 1.0;
    if (ost & 3) {
        if (ost & 1) {
            por.value = KCBRT2;
        }
        else {
            por.value = KCBRT4;
        }
    }
    if (x < 0) exp += 0x8000000000000000LL;
    por.llong = __builtin_e2k_paddd (por.llong, exp);
#if __iset__ >= 6
    _type_double_bits ly, lres, lres1;
    ly.value = y;
    lres.value = x0.value * por.value;
    lres1.value = constcbrtf_dop[ind] * por.value;
    ly.llong = __builtin_e2k_fnmad (lres1.llong, ly.llong, lres.llong);
    return (FL) ly.value;
#else /* __iset__ < 6 */
    return (FL) (x0.value * por.value - constcbrtf_dop[ind] * por.value * y);
#endif /* __iset__ < 6 */

#if 0 /* исходный алгоритм из math, но без вызовов и немного ускоренный.
         На 16 тактов хуже, но не теряет на загрузке таблиц в кэш */

#define CBRT2 1.2599210498948731648             /* 2^(1/3) */
#define SQR_CBRT2 1.5874010519681994748         /* 2^(2/3) */

static const double factor[5] =
{
  1.0 / SQR_CBRT2 / 2,
  1.0 / CBRT2 / 2,
  1.0 / 2,
  CBRT2 / 2,
  SQR_CBRT2 / 2
};
    _type_float_bits arg;
    _type_double_bits darg;
    DB ym, u, t2;
    int exp;

    arg.value = ffabs (x);
    if (__glibc_unlikely (arg.int0 >= 0x7f800000 || arg.int0 == 0))
        return x + x;                                       /* 0, NaN or Inf */
    darg.value = (DB) x;
    exp = exponent (darg) - 1022;
    darg.llong &= ~0xfff0000000000000LL; /* обнуляем порядок и знак */
    darg.llong |= 0x3fe0000000000000LL; /* вставляем 0-й порядок */

    u = 0.492659620528969547 + 0.697570460207922770 * darg.value
                             - 0.191502161678719066 * darg.value * darg.value;
    t2 = u * u * u;
    ym = (t2 + 2.0 * darg.value) / (t2 + 0.5 * darg.value) * (u * factor[2 + exp % 3]);
    arg.value = (FL) ym;
    exp = (exp / 3) << 23;
    if (x < 0) exp += 0x80000000;
    arg.int0 += exp;
    return arg.value;
#endif
}
weak_alias (__cbrtf, cbrtf)
